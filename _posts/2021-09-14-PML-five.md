---
title : "[혼자공부하는 머신러닝 + 딥러닝] 5_K-최근접 이웃 회귀"
excerpt : "03-1. K-최근접 이웃 회귀"

categories:
    - PML
tages:
    - PML

toc : true
toc_sticky: true

date: 2021-09-14
#last_modified_at: 2021-09-12
---
# 4. K-최근접 이웃 회귀
- 지도 학습의 한 종류인 회귀 문제를 이해하고 K-최근접 이웃 알고리즘을 사용해 농어의 무게를 예측하는 회귀 문제를 풀어 본다.
- 도미와 빙어에 이어 농어를 추가하려고 한다.
- 농어에는 문제가 있다. 농어의 무게가 잘못 측정된 상황인 것이다.
- 지도학습에는 크게 분류와 **회귀**로 나뉜다. 회귀는 클래스 중 하나로 분류하는 것이 아니라 임의의 어떤 수를 예측하는 것을 말한다.
- 혹은 두 변수의 상관관계를 분석하는 방법을 회귀라고 한다.


## 1. 들어가며
- 먼저 필요한 라이브러리를 불러온다. 그리고 필요한 농어 데이터를 불러온다. (파이썬 리스트가 아니라 넘파이 배열로 불러온다.)


```python
import numpy as np
import matplotlib.pyplot as plt

from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsRegressor
from sklearn.metrics import mean_absolute_error
```


```python
perch_length = np.array([8.4, 13.7, 15.0, 16.2, 17.4, 18.0, 18.7, 19.0, 19.6, 20.0, 21.0,
       21.0, 21.0, 21.3, 22.0, 22.0, 22.0, 22.0, 22.0, 22.5, 22.5, 22.7,
       23.0, 23.5, 24.0, 24.0, 24.6, 25.0, 25.6, 26.5, 27.3, 27.5, 27.5,
       27.5, 28.0, 28.7, 30.0, 32.8, 34.5, 35.0, 36.5, 36.0, 37.0, 37.0,
       39.0, 39.0, 39.0, 40.0, 40.0, 40.0, 40.0, 42.0, 43.0, 43.0, 43.5,
       44.0])
perch_weight = np.array([5.9, 32.0, 40.0, 51.5, 70.0, 100.0, 78.0, 80.0, 85.0, 85.0, 110.0,
       115.0, 125.0, 130.0, 120.0, 120.0, 130.0, 135.0, 110.0, 130.0,
       150.0, 145.0, 150.0, 170.0, 225.0, 145.0, 188.0, 180.0, 197.0,
       218.0, 300.0, 260.0, 265.0, 250.0, 250.0, 300.0, 320.0, 514.0,
       556.0, 840.0, 685.0, 700.0, 700.0, 690.0, 900.0, 650.0, 820.0,
       850.0, 900.0, 1015.0, 820.0, 1100.0, 1000.0, 1100.0, 1000.0,
       1000.0])
```


```python
plt.scatter(perch_length, perch_weight)
plt.xlabel('length')
plt.ylabel('weight')
plt.show()
```


​    
![output_4_0](https://user-images.githubusercontent.com/37393115/133206172-72cdec72-e8c7-4911-84d3-1e2b0b951ddc.png)
​    


- 산점도를 통해 데이터를 들여다 보면, 선형적 형태를 띄고 있으므로 길이와 무게가 비례한다는 것을 알 수 있다.
- 이를 앞선 데이터들과 마찬가지로 훈련세트와 테스트세트로 분할한다. 하지만 주의해야 할것은 사이킷런에서 훈련세트는 2차원 배열이여야 한다. 이를 위해 reshape()를 사용해 배열을 2차원배열로 바꿔주도록 한다.


```python
train_input, test_input, train_target, test_target = train_test_split(perch_length, perch_weight, random_state = 42)
```


```python
test_array = np.array([1,2,3,4])
print(test_array.shape)
```

    (4,)

```python
test_array = test_array.reshape(2,2)
print(test_array.shape)
```

    (2, 2)

```python
train_input = train_input.reshape(-1, 1)
test_input = test_input.reshape(-1, 1)
print(train_input.shape, test_input.shape)
```

    (42, 1) (14, 1)


## 2. K최근접 이웃 회귀


```python
knr = KNeighborsRegressor()
knr.fit(train_input, train_target)
```


    KNeighborsRegressor(algorithm='auto', leaf_size=30, metric='minkowski',
                        metric_params=None, n_jobs=None, n_neighbors=5, p=2,
                        weights='uniform')


```python
print(knr.score(test_input, test_target))
```

    0.9928094061010639




- 이 점수는 분류에서는 정확도이다. 하지만 회귀에서는 정확한 숫자를 맞춘다는 것은 불가능하다. 왜냐하면 예측하는 값이나 타깃 모두 임의의 수치이기 때문이다.
- 회귀의 경우에는 조금 다른 값으로 평가되는 이 점수를 **결정계수**라고 한다. 


```python
test_prediction = knr.predict(test_input)

mae = mean_absolute_error(test_target, test_prediction)
print(mae)
```

    19.157142857142862




- 위의 결정계수값이 얼마나 좋은지 알아보기가 수비지 않다. 이를 위해 타깃과 예측한 값 사이의 차이를 구해보면 어느정도 에측이 벗어났는지 가늠할 수 있다.
- 이를 위해 사이킷런은 sklaern.metrics 패키지 아래 여러가지 측정 도구를 제공한다. 이 중에서 mean_absolute_error는 타깃과 예측의 절댓값 오차를 평균하여 반환한다.
- 지금까지는 훈련한 모델로 테스트세트를 평가했다. 하지만 훈련한 모델로 훈련세트를 평가하면 어떻게 될까? 


```python
print(knr.score(train_input, train_target))
```

    0.9698823289099255


## 3. 과소적합, 과대적합
- 결과를 살펴보면 훈련세트로 훈련한 모델로 훈련세트를 평가했는데 오히려 테스트세트를 평가할 때보다 감소했다. 
- 이와 같거나 반대의 경우를 **과대적합**, **과소적합**이라 하는데, 과대적합은 훈련 세트에서 점수가 좋은데 반해 테스트 세트에서는 점수가 굉장히 나쁘다면 모델이 훈련 세트에 과대적합 된 상태라고 보고, 반대로 훈련 세트보다 테스트 세트의 점수가 높거나 두 점수가 모두 낮은 경우 이를 과소적합 상태라고 한다.
- 이 데이터는 현재 과소적합 상태라는 것을 알 수 있다.
- 이를 해결하기 위해서 모델을 더 복잡하게 만들면 된다. k-최근접 이웃에서는 이웃의 개수를 줄이면 국지적 패턴에 민감해지기 때문에 모델이 더 복잡해진다.


```python
knr.n_neighbors = 3
knr.fit(train_input, train_target)
print(knr.score(train_input, train_target))
```

    0.9804899950518966




- 디폴트 값이 5개인 것을, 3개로 줄여서 국지적 패턴에 민감하게 만든다.
- 그 뒤 다시 테스트세트에 대한 평가점수를 확인한다.
- 이후 하단의 결과처럼 테스트세트를 평가한 후 비교하면 과소적합 문제가 해결되어 테스트 세트의 점수가 더 낫게 나오는 것을 확인할 수 있었다.


```python
print(knr.score(test_input, test_target))
```

    0.974645996398761


## 4. 마치며
- 이번시간엔 이전의 분류에 이어 지도학습의 큰 유형 중 하나인 회귀에 대해 배워보는 시간이였다.
